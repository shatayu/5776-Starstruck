#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in2,    Gyro,           sensorGyro)
#pragma config(Sensor, in3,    ,               sensorGyro)
#pragma config(Sensor, in4,    LiftPot,        sensorPotentiometer)
#pragma config(Sensor, in6,    ,               sensorGyro)
#pragma config(Sensor, dgtl1,  ClawSolenoid,   sensorDigitalOut)
#pragma config(Sensor, dgtl2,  Transmission,   sensorDigitalOut)
#pragma config(Sensor, I2C_1,  REncoder,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  LEncoder,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           FLDrive,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           BLDrive,       tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port4,           RDrive,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           LLift,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           RLift,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           LDrive,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           BRDrive,       tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port9,           FRDrive,       tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2);
#pragma competitionControl(Competition);
#include "Vex_Competition_Includes.c";
/*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*/

typedef struct {
	int lift;
	int LDrive;
	int RDrive;
	int claw;
	int transmissionOn;
	int transmissionOff;
	int liftUp;
	int liftDown;
	int PIDOn;
	int PIDOff;
} Controls;

Controls c;

bool partnerControl = false;

task controls() {
	while (true) {
		if (!partnerControl) {
			c.LDrive = vexRT[Ch3] + vexRT[Ch1] + vexRT[Ch3Xmtr2];
			c.RDrive = vexRT[Ch3] - vexRT[Ch1] + vexRT[Ch2Xmtr2];
			c.claw = (vexRT[Btn5D] || vexRT[Btn5DXmtr2]);
			c.transmissionOn = (vexRT[Btn8U] || vexRT[Btn8UXmtr2]);
			c.transmissionOff = (vexRT[Btn8D] || vexRT[Btn8DXmtr2]);
			c.liftUp = (vexRT[Btn6U] || vexRT[Btn6UXmtr2]);
			c.liftDown = (vexRT[Btn6D] || vexRT[Btn6DXmtr2]);
			c.PIDOn = (vexRT[Btn7U] || vexRT[Btn7UXmtr2]);
			c.PIDOff = (vexRT[Btn7D] || vexRT[Btn7DXmtr2]);
		} else {
			c.LDrive = vexRT[Ch3] + vexRT[Ch1];
			c.RDrive = vexRT[Ch3] - vexRT[Ch1];
			c.claw = vexRT[Btn5D];
			c.transmissionOn = vexRT[Btn8U];
			c.transmissionOff = vexRT[Btn8D];
			c.liftUp = vexRT[Btn6U];
			c.liftDown = vexRT[Btn6D];
			c.PIDOn = vexRT[Btn7U];
			c.PIDOff = vexRT[Btn7D];
		}
		wait1Msec(20);

		if (vexRT[Btn7L])
			partnerControl = true;

		if (vexRT[Btn7R])
			partnerControl = false;
	}
}

#include "drive/toggle.h"
#include "drive/functions.h"

#include "PID.h"

#include "auton/constants.h"
#include "auton/functions.h"
#include "auton/auton.h"

void pre_auton() {
	calibrate();
}

task autonomous() {
	//backFenceRight(1);
	//cubeScoreLeft();
	//cubeScoreLeft();
	backFenceLeft();
}

task usercontrol() {
	Toggle claw;
	claw.state = 0;
	claw.buffer = 0;

	startTask(controls);
	startTask(lift);

	while (true) {
		// arcade drive
		moveDrive(c.LDrive, c.RDrive);

		// claw
		if (c.claw && (c.claw != claw.buffer))  // if button is pressed and it was not pressed before
	   	claw.state = claw.state ? 0 : 1;

		claw.buffer = c.claw;
		clawState(claw.state);

		// transmission
		if (c.transmissionOn)
			transmissionState(OPEN);

		if (c.transmissionOff)
			transmissionState(CLOSED);

		if (vexRT[Btn8L])
			startTask(deploy);

		wait1Msec(20);
	}
}
// 680 - lift down state, position needed for turns
